<#@ template language="C#" debug="True" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension="cs" #>
<#@ include file="T4Toolbox.tt" #>
// ------------------------------------------------------------------------------
//  <auto-generated>
//    Generated by NCop Copyright ©
//    Changes to this file may cause incorrect behavior and will be lost if
//    the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace NCop.Aspects.Extensions
{
	using System;
	using System.Reflection;
	using NCop.Aspects.Engine;
	using NCop.Core.Extensions;
	using System.Collections.Generic;

	internal static class AspectArgsImplResolver
	{
		private static readonly IDictionary<int, Type> funcEventArgsMap = null;
		private static readonly IDictionary<int, Type> actionEventArgsMap = null;
		private static readonly IDictionary<int, Type> funcExecutionArgsMap = null;
		private static readonly IDictionary<int, Type> actionExecutionArgsMap = null;
		private static readonly IDictionary<int, Type> funcInterceptionArgsMap = null;
		private static readonly IDictionary<int, Type> actionInterceptionArgsMap = null;

		static AspectArgsImplResolver() {
			funcEventArgsMap = new Dictionary<int, Type>();
			actionEventArgsMap = new Dictionary<int, Type>();
			funcExecutionArgsMap = new Dictionary<int, Type>();
			actionExecutionArgsMap = new Dictionary<int, Type>();
			funcInterceptionArgsMap = new Dictionary<int, Type>();
			actionInterceptionArgsMap = new Dictionary<int, Type>();

			actionExecutionArgsMap.Add(0, typeof(ActionExecutionArgsImpl<>));	
			actionInterceptionArgsMap.Add(0, typeof(ActionInterceptionArgsImpl<>));

<#
foreach (var i in Enumerable.Range(1, 8)) {
	string commas = string.Concat(Enumerable.Repeat(",", i));
#>
			funcExecutionArgsMap.Add(<#= i #>, typeof(FunctionExecutionArgsImpl<<#=commas#>>));	
			actionExecutionArgsMap.Add(<#= i #>, typeof(ActionExecutionArgsImpl<<#= commas #>>));	
			funcEventArgsMap.Add(<#= i #>, typeof(EventFunctionInterceptionArgsImpl<<#=commas#>>));
			actionEventArgsMap.Add(<#= i #>, typeof(EventActionInterceptionArgsImpl<<#= commas #>>));
			actionInterceptionArgsMap.Add(<#= i #>, typeof(ActionInterceptionArgsImpl<<#= commas #>>));	
			funcInterceptionArgsMap.Add(<#= i #>, typeof(FunctionInterceptionArgsImpl<<#= commas #>>));							
<#
	if (i == 8) {
		commas += ",";#>
			
			funcExecutionArgsMap.Add(9, typeof(FunctionExecutionArgsImpl<<#= commas #>>));	
			funcEventArgsMap.Add(9, typeof(EventFunctionInterceptionArgsImpl<<#=commas#>>));
			funcInterceptionArgsMap.Add(9, typeof(FunctionInterceptionArgsImpl<<#= commas #>>));							
<#}
	else{
		WriteLine(""); 
	}
}#>
		}

		internal static Type MakeGenericArgsType(this Type argumentsType, MethodInfo aspectMember, params Type[] typeArguments) {
			Type type = null;
			int parametersCount = argumentsType.GetGenericArguments().Length;

			if (typeof(IEventFunctionInterceptionArgs).IsAssignableFrom(argumentsType)) {
                type = funcEventArgsMap[parametersCount];
            }
            else if (typeof(IEventActionInterceptionArgs).IsAssignableFrom(argumentsType)) {
                type = actionEventArgsMap[parametersCount];
            }
			else if (typeof(IPropertyInterceptionArgs).IsAssignableFrom(argumentsType)) {
                type = aspectMember.HasReturnType() ? typeof(GetPropertyInterceptionArgsImpl<,>) : typeof(SetPropertyInterceptionArgsImpl<,>);
            }
			else if (typeof(IFunctionInterceptionArgs).IsAssignableFrom(argumentsType)) {
				type = funcInterceptionArgsMap[parametersCount];
			}
			else if (typeof(IActionInterceptionArgs).IsAssignableFrom(argumentsType)) {
				type = actionInterceptionArgsMap[parametersCount];
			}
			else if (typeof(IFunctionExecutionArgs).IsAssignableFrom(argumentsType)) {
				type = funcExecutionArgsMap[parametersCount];
			}
			else {
				type = actionExecutionArgsMap[parametersCount];
			}

			return type.MakeGenericType(typeArguments);
		}

		internal static bool IsFunctionAspectArgs(this Type argumentsType) {
			return typeof(IFunctionExecutionArgs).IsAssignableFrom(argumentsType)||
				   typeof(IFunctionInterceptionArgs).IsAssignableFrom(argumentsType);
		}
	}
}